<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Face demo — MediaPipe + HF Backend</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 8px; }
    #row { display:flex; gap:12px; align-items:flex-start; }
    #videoWrap { position:relative; }
    video, canvas { width: 640px; height: 480px; border: 1px solid #333; background:#000; }
    #controls { margin-top:8px; }
    button { padding:8px 12px; margin-right:8px; }
    #log { white-space:pre-wrap; font-size:12px; margin-top:8px; max-height:220px; overflow:auto; border:1px solid #ddd; padding:8px; background:#fafafa; }
    .small { width:112px; height:112px; border:1px solid #666; display:block; margin-top:6px; }
  </style>
</head>
<body>
  <h2>Face demo — MediaPipe + Hugging Face Backend</h2>
  <div id="row">
    <div id="videoWrap">
      <video id="video" autoplay muted playsinline crossorigin="anonymous"></video>
      <canvas id="overlay"></canvas>
    </div>
    <div id="controlsWrap">
      <canvas id="alignedThumb" class="small"></canvas>
      <div id="controls">
        <button id="enrollBtn">Enroll (name current largest face)</button>
        <button id="clearGalleryBtn">Clear Saved Gallery</button>
      </div>
      <div id="status">Connecting to backend...</div>
    </div>
  </div>

  <div id="log"></div>

  <!-- MediaPipe Face Mesh - CORRECTED URLs -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  (async () => {
    // -------- CONFIG
    const BACKEND_URL = 'wss://sommyonyekwelu-face-embedding-backend.hf.space/ws'; 

    const VIDEO_W = 640, VIDEO_H = 480;
    const EMBED_W = 112, EMBED_H = 112;
    const CANONICAL_5 = [ [30.2946, 51.6963], [65.5318, 51.5014], [48.0252, 71.7366], [33.5493, 92.3655], [62.7299, 92.2041] ];
    const TRACKER_PARAMS = { matchThreshold: 0.62, galleryThreshold: 0.58, iouThreshold: 0.45, maxAgeFrames: 300, embBufferSize: 6, minEmbForNewTrack: true };
    const PAD_FACTOR = 1.4;
    // -------- end CONFIG

    const logEl = document.getElementById('log');
    function log(...s){ logEl.textContent += s.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }

    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    overlay.width = VIDEO_W; overlay.height = VIDEO_H;
    const ctx = overlay.getContext('2d');
    const alignedThumb = document.getElementById('alignedThumb');
    alignedThumb.width = EMBED_W; alignedThumb.height = EMBED_H;
    const alignedThumbCtx = alignedThumb.getContext('2d');
    const status = document.getElementById('status');

    let tracker = null, frameCounter = 0, faceMesh = null;
    const idToName = {};
    const tmpCanvas = document.createElement('canvas');
    const alignedTmpCanvas = document.createElement('canvas');
    let isProcessing = false;
    let pendingFace = null; 

    class EmbeddingTracker{constructor(opts={}){this.matchThreshold=opts.matchThreshold??0.62;this.galleryThreshold=opts.galleryThreshold??0.58;this.iouThreshold=opts.iouThreshold??0.45;this.maxAgeFrames=opts.maxAgeFrames??150;this.embBufferSize=opts.embBufferSize??8;this.minEmbForNewTrack=opts.minEmbForNewTrack??true;this.nextId=1;this.tracks={};this.activeTrackIds=new Set();} _newId(){return`P${this.nextId++}`} static cosine(a,b){if(!a||!b||a.length!==b.length)return-1;let dot=0,na=0,nb=0;for(let i=0;i<a.length;i++){dot+=a[i]*b[i];na+=a[i]*a[i];nb+=b[i]*b[i];} return dot/(Math.sqrt(na)*Math.sqrt(nb)+1e-10)} static iou(b1,b2){const x1=Math.max(b1.x,b2.x),y1=Math.max(b1.y,b2.y),x2=Math.min(b1.x+b1.w,b2.x+b2.w),y2=Math.min(b1.y+b1.h,b2.y+b2.h);const iw=Math.max(0,x2-x1),ih=Math.max(0,y2-y1);const inter=iw*ih,union=b1.w*b1.h+b2.w*b2.h-inter;return union<=0?0:inter/union} _computeMean(track){if(!track.embBuffer||track.embBuffer.length===0)return null;const K=track.embBuffer.length,D=track.embBuffer[0].length;const mean=new Float32Array(D);for(let i=0;i<K;i++){const e=track.embBuffer[i];for(let d=0;d<D;d++)mean[d]+=e[d];} for(let d=0;d<D;d++)mean[d]/=K;let norm=0;for(let d=0;d<D;d++)norm+=mean[d]*mean[d];norm=Math.sqrt(norm)+1e-10;for(let d=0;d<D;d++)mean[d]/=norm;track.embMean=mean;return mean} _pushEmb(track,emb){if(!emb)return;const e=(emb instanceof Float32Array)?emb.slice(0):new Float32Array(emb);if(!track.embBuffer)track.embBuffer=[];track.embBuffer.push(e);if(track.embBuffer.length>this.embBufferSize)track.embBuffer.shift();this._computeMean(track)} _createTrack(det,frameIdx){const id=this._newId();const track={id,embBuffer:[],embMean:null,lastSeenFrame:frameIdx,bbox:det.bbox,active:true,createdAt:Date.now()};if(det.emb)this._pushEmb(track,det.emb);this.tracks[id]=track;this.activeTrackIds.add(id);return track} _updateTrack(track,det,frameIdx){track.lastSeenFrame=frameIdx;track.bbox=det.bbox;if(det.emb)this._pushEmb(track,det.emb);track.active=true;this.activeTrackIds.add(track.id);return track} prune(frameIdx){for(const id in this.tracks){const t=this.tracks[id];if(frameIdx-t.lastSeenFrame>this.maxAgeFrames){t.active=false;this.activeTrackIds.delete(id);}}} getActiveTracks(){return Array.from(this.activeTrackIds).map(id=>this.tracks[id])} updateOne(det,frameIdx=0){if(det.emb){let best={id:null,score:-2};for(const id of this.activeTrackIds){const t=this.tracks[id];if(!t.embMean)continue;const s=EmbeddingTracker.cosine(det.emb,t.embMean);if(s>best.score)best={id,score:s};} if(best.id&&best.score>=this.matchThreshold){const t=this.tracks[best.id];this._updateTrack(t,det,frameIdx);return{id:t.id,score:best.score,matchedBy:'emb'};} let bestGal={id:null,score:-2};for(const id in this.tracks){const t=this.tracks[id];if(!t.embMean)continue;const s=EmbeddingTracker.cosine(det.emb,t.embMean);if(s>bestGal.score)bestGal={id,score:s};} if(bestGal.id&&bestGal.score>=this.galleryThreshold){const t=this.tracks[bestGal.id];this._updateTrack(t,det,frameIdx);return{id:t.id,score:bestGal.score,matchedBy:'gallery'};}} let bestIou={id:null,score:0};for(const id of this.activeTrackIds){const t=this.tracks[id];const s=EmbeddingTracker.iou(t.bbox,det.bbox);if(s>bestIou.score)bestIou={id,score:s};} if(bestIou.id&&bestIou.score>=this.iouThreshold){const t=this.tracks[bestIou.id];this._updateTrack(t,det,frameIdx);return{id:t.id,score:bestIou.score,matchedBy:'iou'};} if(det.emb||!this.minEmbForNewTrack){const newTrack=this._createTrack(det,frameIdx);return{id:newTrack.id,score:null,matchedBy:'new'};} return{id:null,score:null,matchedBy:'none'}} updateBatch(detections,frameIdx=0){const assignments=[];const idxs=detections.map((_,i)=>i).sort((a,b)=>(detections[b].emb?1:0)-(detections[a].emb?1:0));for(const i of idxs){const det=detections[i];assignments[i]=this.updateOne(det,frameIdx);} this.prune(frameIdx);return assignments} saveGallery(key='face_gallery_v1'){const dump=[];for(const id in this.tracks){const t=this.tracks[id];if(t.embMean)dump.push({id:t.id,emb:Array.from(t.embMean),lastSeen:t.lastSeenFrame,createdAt:t.createdAt});} localStorage.setItem(key,JSON.stringify(dump))} loadGallery(key='face_gallery_v1'){const raw=localStorage.getItem(key);if(!raw)return;try{const dump=JSON.parse(raw);for(const e of dump){const t={id:e.id,embBuffer:[new Float32Array(e.emb)],embMean:new Float32Array(e.emb),lastSeenFrame:e.lastSeen??0,bbox:{x:0,y:0,w:0,h:0},active:false,createdAt:e.createdAt??Date.now()};this.tracks[t.id]=t;} const maxId=Object.keys(this.tracks).reduce((m,id)=>Math.max(m,parseInt(id.replace('P',''))),0);if(maxId>=this.nextId)this.nextId=maxId+1;}catch(e){console.warn('loadGallery failed',e)}}}
    function umeyama(srcPts,dstPts){const N=srcPts.length;if(N<2)return;const muX=[0,0],muY=[0,0];for(let i=0;i<N;i++){muX[0]+=srcPts[i][0];muX[1]+=srcPts[i][1];muY[0]+=dstPts[i][0];muY[1]+=dstPts[i][1];}muX[0]/=N;muX[1]/=N;muY[0]/=N;muY[1]/=N;const Xc=srcPts.map(p=>[p[0]-muX[0],p[1]-muX[1]]);const Yc=dstPts.map(p=>[p[0]-muY[0],p[1]-muY[1]]);let cov=[[0,0],[0,0]];for(let i=0;i<N;i++){cov[0][0]+=Yc[i][0]*Xc[i][0];cov[0][1]+=Yc[i][0]*Xc[i][1];cov[1][0]+=Yc[i][1]*Xc[i][0];cov[1][1]+=Yc[i][1]*Xc[i][1];}for(let i=0;i<2;i++)for(let j=0;j<2;j++)cov[i][j]/=N;const ATA=[[cov[0][0]*cov[0][0]+cov[1][0]*cov[1][0],cov[0][0]*cov[0][1]+cov[1][0]*cov[1][1]],[cov[0][1]*cov[0][0]+cov[1][1]*cov[1][0],cov[0][1]*cov[0][1]+cov[1][1]*cov[1][1]]];const tr=ATA[0][0]+ATA[1][1],det=ATA[0][0]*ATA[1][1]-ATA[0][1]*ATA[1][0];const tmp=Math.sqrt(Math.max(0,tr*tr/4-det));const s1=Math.sqrt(Math.max(0,tr/2+tmp));const s2=Math.sqrt(Math.max(0,tr/2-tmp));function eigv(A,lam){const a=A[0][0]-lam,b=A[0][1];return Math.abs(a)+Math.abs(b)<1e-8?[1,0]:[-b,a];}const v1=eigv(ATA,tr/2+tmp);const v1n=Math.hypot(v1[0],v1[1])||1;const V=[[v1[0]/v1n,-v1[1]/v1n],[v1[1]/v1n,v1[0]/v1n]];let U=[[1,0],[0,1]];if(s1>1e-8){const c0=[cov[0][0]*V[0][0]+cov[0][1]*V[1][0],cov[1][0]*V[0][0]+cov[1][1]*V[1][0]];const n0=Math.hypot(c0[0],c0[1])||1;U[0][0]=c0[0]/n0;U[1][0]=c0[1]/n0;U[0][1]=-U[1][0];U[1][1]=U[0][0];}const dU=U[0][0]*U[1][1]-U[0][1]*U[1][0],dV=V[0][0]*V[1][1]-V[0][1]*V[1][0];const S=[1,1];if(dU*dV<0)S[1]=-1;const Vt=[[V[0][0],V[1][0]],[V[0][1],V[1][1]]];const US=[[U[0][0]*S[0],U[0][1]*S[1]],[U[1][0]*S[0],U[1][1]*S[1]]];const R=[[US[0][0]*Vt[0][0]+US[0][1]*Vt[1][0],US[0][0]*Vt[0][1]+US[0][1]*Vt[1][1]],[US[1][0]*Vt[0][0]+US[1][1]*Vt[1][0],US[1][0]*Vt[0][1]+US[1][1]*Vt[1][1]]];let v=0;for(let i=0;i<N;i++)v+=Xc[i][0]*Xc[i][0]+Xc[i][1]*Xc[i][1];v/=N;const sc=v<1e-12?1:((s1*S[0]+s2*S[1])/v);const RmuX=[R[0][0]*muX[0]+R[0][1]*muX[1],R[1][0]*muX[0]+R[1][1]*muX[1]];const t=[muY[0]-sc*RmuX[0],muY[1]-sc*RmuX[1]];return[[sc*R[0][0],sc*R[0][1],t[0]],[sc*R[1][0],sc*R[1][1],t[1]],[0,0,1]];}

    const socket = new WebSocket(BACKEND_URL);
    socket.onopen = () => { log('Connected to backend.'); status.textContent = 'Ready'; };
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.embedding && pendingFace) {
        pendingFace.emb = data.embedding;
        tracker.updateOne(pendingFace, frameCounter);
        pendingFace = null; 
        isProcessing = false; 
      }
    };
    socket.onerror = (error) => { log('WebSocket Error:', JSON.stringify(error, Object.getOwnPropertyNames(error))); status.textContent = 'Connection Error'; };
    socket.onclose = () => { log('Disconnected from backend.'); status.textContent = 'Disconnected'; };
    
    async function onResults(results) {
      frameCounter++;
      ctx.clearRect(0, 0, overlay.width, overlay.height);
      ctx.drawImage(results.image, 0, 0, overlay.width, overlay.height);

      const allDetections = [];
      if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
        for (const landmarks of results.multiFaceLandmarks) {
            const pts = landmarks.map(l => [l.x * VIDEO_W, l.y * VIDEO_H]);
            let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity; for(const p of pts){if(p[0]<minx)minx=p[0];if(p[1]<miny)miny=p[1];if(p[0]>maxx)maxx=p[0];if(p[1]>maxy)maxy=p[1];} const cx=(minx+maxx)/2,cy=(miny+maxy)/2; let sz=Math.max(maxx-minx,maxy-miny)*PAD_FACTOR; sz=Math.max(sz,40); let x0=Math.round(cx-sz/2),y0=Math.round(cy-sz/2),w=Math.round(sz),h=Math.round(sz); if(x0<0){w+=x0;x0=0;}if(y0<0){h+=y0;y0=0;} if(x0+w>VIDEO_W)w=VIDEO_W-x0;if(y0+h>VIDEO_H)h=VIDEO_H-y0; if(w<=0||h<=0)continue;
            allDetections.push({ bbox: {x:x0,y:y0,w:w,h:h}, landmarks: pts, emb: null });
        }
      }
      
      tracker.updateBatch(allDetections, frameCounter);
      
      if (!isProcessing && pendingFace === null && allDetections.length > 0) {
        allDetections.sort((a,b) => (b.bbox.w*b.bbox.h) - (a.bbox.w*a.bbox.h));
        const faceToProcess = allDetections[0];

        isProcessing = true; 
        pendingFace = faceToProcess;

        const key5 = [faceToProcess.landmarks[33], faceToProcess.landmarks[263], faceToProcess.landmarks[1], faceToProcess.landmarks[61], faceToProcess.landmarks[291]];
        const src5 = key5.map(p => [(p[0]-faceToProcess.bbox.x)*(EMBED_W/faceToProcess.bbox.w), (p[1]-faceToProcess.bbox.y)*(EMBED_H/faceToProcess.bbox.h)]);
        const M = umeyama(src5, CANONICAL_5);
        
        alignedTmpCanvas.width = EMBED_W; alignedTmpCanvas.height = EMBED_H;
        const actx = alignedTmpCanvas.getContext('2d');
        actx.clearRect(0,0,EMBED_W,EMBED_H); actx.save(); actx.setTransform(M[0][0],M[1][0],M[0][1],M[1][1],M[0][2],M[1][2]);
        tmpCanvas.width=faceToProcess.bbox.w;tmpCanvas.height=faceToProcess.bbox.h; tmpCanvas.getContext('2d').drawImage(video,faceToProcess.bbox.x,faceToProcess.bbox.y,faceToProcess.bbox.w,faceToProcess.bbox.h,0,0,faceToProcess.bbox.w,faceToProcess.bbox.h);
        actx.drawImage(tmpCanvas,0,0,faceToProcess.bbox.w,faceToProcess.bbox.h); actx.restore();
        
        const dataUrl = alignedTmpCanvas.toDataURL('image/jpeg', 0.9);
        socket.send(dataUrl);

        alignedThumbCtx.clearRect(0,0,EMBED_W,EMBED_H);
        alignedThumbCtx.drawImage(alignedTmpCanvas,0,0,EMBED_W,EMBED_H);
      }
      
      const activeTracks = tracker.getActiveTracks();
      for (const track of activeTracks) {
          ctx.strokeStyle = 'lime'; ctx.lineWidth = 2;
          ctx.strokeRect(track.bbox.x, track.bbox.y, track.bbox.w, track.bbox.h);
          const label = idToName[track.id] || track.id;
          ctx.fillStyle = 'yellow'; ctx.font = '16px Arial';
          ctx.fillText(label, track.bbox.x, Math.max(16, track.bbox.y - 6));
      }
    }

    tracker = new EmbeddingTracker(TRACKER_PARAMS);
    tracker.loadGallery();
    try { Object.assign(idToName, JSON.parse(localStorage.getItem('idToName') || '{}')); } catch (e) {}

    faceMesh = new FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
    faceMesh.setOptions({ maxNumFaces: 4, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    faceMesh.onResults(onResults);

    const camera = new Camera(video, {
      onFrame: async () => { await faceMesh.send({ image: video }); },
      width: VIDEO_W,
      height: VIDEO_H
    });
    await camera.start();
    log('Camera started. Ready.');

    document.getElementById('enrollBtn').onclick = () => { const active = tracker.getActiveTracks().sort((a,b) => (b.bbox.w*b.bbox.h) - (a.bbox.w*a.bbox.h)); if(active.length === 0){ alert('No active face to enroll'); return; } const t = active[0]; const name = prompt('Enter name for this person:'); const label = (name && name.trim().length>0) ? name.trim() : t.id; idToName[t.id] = label; try { localStorage.setItem('idToName', JSON.stringify(idToName)); tracker.saveGallery(); log('Enrolled', t.id, 'as', label); } catch(e){ console.warn('save failed', e); } };
    document.getElementById('clearGalleryBtn').onclick = () => { if(confirm('Clear saved gallery and labels?')){ localStorage.removeItem('face_gallery_v1'); localStorage.removeItem('idToName'); tracker = new EmbeddingTracker(TRACKER_PARAMS); for(const k in idToName) delete idToName[k]; log('Cleared saved gallery and labels'); } };
    window.addEventListener('beforeunload', () => { try { tracker.saveGallery(); localStorage.setItem('idToName', JSON.stringify(idToName)); } catch(e){} });

    log('Setup complete.');
  })();
  </script>
</body>
</html>
